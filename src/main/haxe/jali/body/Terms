package jali.body;

class Terms extends Clazz{
  public function head<T>(self:Term<T>){
    return switch(self){
      case TOf(hd, _) : hd;
    }
  }
  public function head_only<T>(self:Term<T>):Option<Head<T>>{
    return self.cat().snd().ds().is_defined() ? None : self.cat().fst();
  }
  public function tail<T>(self:Term<T>){
    return switch(self){
      case TOf(_, xs) : __.option(xs).defv([]);
    }
  }
  public function tail_body<T>(self:Term<T>){
    return switch(self){
      case TOf(_, tail ) : tail.body();
    }
  }
  public function code_only<T>(self:Term<T>):Option<String>{
    return self.cat().fst().code();
  }
  public function code<T>(self:Term<T>):Option<Couple<String,Tail<T>>>{
    return 
      ((head:Head<T>) -> head.code()).fn()
      .pair(__.through())
      .into((l,r) -> l.map(__.couple.bind(_,r)))
      (self.cat());
  }
  public function code_body<T>(self:Term<T>):Option<Couple<String,Term<T>>>{
    return self.body().fmap(
      tp -> __.lbump()(tp.lmap( head -> head.code()))
    );
  }

  public function body<T>(self:Term<T>):Option<Couple<Head<T>,Term<T>>>{
    return __.through().fn()
      .pair((_:Tail<T>) -> _.body())
      .into(
        (head,opt) -> opt.map(__.couple.bind(head))
      )(toCouple(self));
  }
  public function data_only<T>(self:Term<T>):Option<Array<T>>{
    return self.cat().snd().is_defined() ? None : self.cat().fst().data();
  }
  public function data<T>(self:Term<T>):Option<CoupleCat<Array<T>,Tail<T>>>{
    return 
      ((head:Head<T>) -> head.data()).fn()
      .pair(__.through())
      .then(__.lbump())
      (self.cat());
  }
  public function data_body<T>(self:Term<T>):Option<Couple<Array<T>,Term<T>>>{
    return self.body().fmap(
      tp -> __.lbump()(tp.lmap( head -> head.data()))
    );
  }
  public function endata<T>(self:Term<T>,that:Array<T>){
    return switch(self){
      case TOf(Data(data),rest) : TOf(Data(data.concat(that)),rest);
      case TOf(Rest,null)       : TOf(Data(that),Tail.unit());
      case TOf(Rest,rest)       : TOf(Data(that),rest);
      case TOf(Code(_),rest)    : TOf(Data(that),[self]);
    }
  }
  public function concat<T>(self:Term<T>,that:Term<T>):Term<T>{
    return switch(self){
      case TOf(Data(data),rest) : TOf(Rest,[self,that]);
      case TOf(Rest,null)       : TOf(Rest,[that]);
      case TOf(Rest,rest)       : TOf(Rest,rest.ds().snoc(that).prj());
      case TOf(Code(_),rest)    : TOf(Rest,[self,that]);
    }
  }
  public function subtree<T>(self:Term<T>,that:Term<T>):Term<T>{
    return switch(self){
      case TOf(Data(data),rest) : TOf(Data(data),rest.snoc(that));
      case TOf(Rest,null)       : TOf(Rest,[that]);
      case TOf(Rest,rest)       : TOf(Rest,rest.ds().snoc(that).prj());
      case TOf(Code(code),rest) : TOf(Code(code),rest.snoc(that));
    }
  }
  public function both<T>(self:Term<T>,that:Term<T>):Term<T>{
    return TOf(Rest,[self,that]);
  }

  
  
  public function rest<T>(self:Term<T>):Option<Tail<T>>{
    var tup = self.cat();
      return tup.fst().is_term() ? Some(tup.snd()) : None;
  }
  public function rest_body<T>(self:Term<T>):Option<Term<T>>{
    var tup = self.cat();
      return tup.fst().is_term() && tup.snd().length == 1 ? Some(tup.snd()[0]) : None;
  }

  public function toArray<T>(self:Term<T>):Array<Dynamic>{
    return switch(self){
      case TOf(Code(name),rest)   : ([name]:Array<Dynamic>).concat(rest.map(_ -> _.toArray()));
      case TOf(Rest,rest)         : rest.map( _ -> _.toArray());
      case TOf(Data(data),rest)   : (data:Array<Dynamic>).snoc(rest.map( _ -> _.toArray()));
    }
  }
  public function toJsonic<T>(self:Term<T>):Jsonic<T>{
    var stamp = () -> ({
      //type : null,
      rest : []
    }:Jsonic<T>);

    function rec(v:Term<T>):Jsonic<T> return switch v {
      case TOf(Rest, rest): 
        var out = stamp();
            //out.type = JRest;
            out.rest = __.option(rest).defv([]).map(rec);
            out;
      case TOf(Data(data), rest):
        var out = stamp();
            //out.type = JData;
            out.data = data;
            out.rest = __.option(rest).defv([]).map(rec);
            out;
      case TOf(Code(code), rest):
        var out = stamp();
            //out.type = JCode;
            out.code = code;
            out.rest = __.option(rest).defv([]).map(rec);
            out;
    }
    return rec(self);
  }
  public function map<T,U>(fn:T->U,expr:Term<T>){
    return switch expr {
      case TOf(Rest,null)           : TOf(Rest,[]);
      case TOf(Rest,_rest)          : TOf(Rest,_rest.map(map.bind(fn)));
      case TOf(Data(_data),_rest)   : TOf(Data(_data.map(fn)),_rest.map(map.bind(fn)));
      case TOf(Code(_code),_rest)   : TOf(Code(_code),_rest.map(map.bind(fn)));
    }
  }
  public function t_reduce<T,Z>(unit:Void->Z,pure:T->Z,plus:Z->Z->Z,?code:String->Option<T->Z>,expr:Term<T>):Z{
    code = __.option(code).defv((_) -> None);
    var f = t_reduce.bind(unit,pure,plus,code);
    return switch expr {
      case TOf(Rest,null)           : unit();
      case TOf(Rest,_rest)          : _rest.map(f).ds().lfold(plus,unit());
      case TOf(Data(_data), _rest)  : _rest.map(f).ds().lfold(plus,_data.map(pure).lfold(plus,unit()));
      case TOf(Code(_code), _rest)  : _rest.map(t_reduce.bind(unit,code(_code).defv(pure),plus,code)).ds().lfold(plus,unit());
    }
  }
  public function optimise<T>(expr:Term<T>):Term<T>{
    return mod(
      (x:Term<T>) -> switch(x){
        case TOf(hd,null) : TOf(hd,[]);
        case TOf(hd,subs) : subs.ds().all(
          (sub) -> switch(sub){
            case TOf(Rest,_)      : true;
            default               : false;
          }
        ).if_else(
          () -> TOf(hd,subs.ds().map_filter(
            (term) -> switch(term){
              case TOf(Rest,arr)  : Some(arr);
              default             : None;
            }
          ).fmap(_ -> _)),
          () -> TOf(hd,subs)
        );
        default : x;
      },
      expr
    );
  }
  public function codeify(expr:Term<String>):Term<String>{
    return mod(
      (x) -> switch(x){
        case TOf(Data([str]),_rest)   : TOf(Code(str),_rest);
        default                       : x;
      },
      expr
    );
  }
  public function mod<T>(fn:Term<T> -> Term<T>,expr:Term<T>):Term<T>{
    return fn(switch expr {
      case TOf(Rest,null)             : TOf(Rest,[]);
      case TOf(Rest,_rest)            : TOf(Rest,_rest.map(mod.bind(fn)));
      case TOf(Data(_data), _rest)    : TOf(Data(_data),_rest.map(mod.bind(fn)));
      case TOf(Code(_code), _rest)    : TOf(Code(_code),_rest.map(mod.bind(fn)));
    });
  }
  public function walk<T>(fn:Term<T> -> Void,expr:Term<T>):Void{
    fn(expr);
    switch expr{
      case TOf(_,_rest)           :
        for (term in _rest){
          walk(fn,term);
        }
      default : 
    };
  }
  public function reduce<T,Z>(plus:Z->Z->Z,pure:T->Z,unit:Void->Z,code:String->Z,self:Term<T>){
    var f   = reduce.bind(plus,pure,unit,code);
    var fun = (rest:Tail<T>) -> rest.map(f).ds().lfold1(plus).def(unit);
    return switch self {
      case null                   : unit();
      case TOf(Rest, null)        : unit();
      case TOf(Rest, _rest)       : fun(_rest);
      case TOf(Code(_code),_rest) : plus(code(_code),fun(_rest));
      case TOf(Data(_data),_rest) : plus(_data.map(pure).lfold1(plus).def(unit),fun(_rest));
    }
  }
  static public function toStringCompact<T>(self:Term<T>){
    function rec(v:Term<T>,n:Int=0):String{
      var t = '';
      for (i in 0...n){
        t = t + ' ';
      }
      return switch(v){
        case null           : '';
        case TOf(Rest,null) : '';
        case TOf(Rest,rest) : 
          '$t' + rest.map(rec.bind(_,++n)).join('$t');
        case TOf(Data(data),rest) : 
          var head = data.map(Std.string).join(" ");
          '$head$t' + rest.map(rec.bind(_,++n)).join('$t');
        case TOf(Code(code),rest) : 
          '$code$t' + rest.map(rec.bind(_,++n)).join('$t');
      }
    }
    return rec(self);
  }
  public function toString<T>(self:Term<T>){
    function rec(v:Term<T>,n:Int=1):String{
      var t = '';
      for (i in 0...n){
        t = t + '  ';
      }
      var f     = rec.bind(_,++n);
      var lvl   = (arr) -> '\n$t' + arr.join('\n$t');
      var f0    = (arr) -> lvl(arr.map(f));
      return switch(v){
        case TOf(Rest,null)                           : '';
        case TOf(Rest,tail) if(!tail.is_defined())    : '';
        case TOf(Rest,rest) : 
          '$t'    + f0(rest);
        case TOf(Data(data),tail) if(!tail.is_defined()) : 
          var head = data.map(Std.string).join(" ");
          '$head';
        case TOf(Data(data),rest) : 
          var head = data.map(Std.string).join(" ");
          '$head ' + f0(rest);
        case TOf(Code(code),rest) : 
          '$code ' + f0(rest);
      }
    }
    return '\n' + rec(self);
  }
  public function toCouple<T>(self:Term<T>):Couple<Head<T>,Tail<T>>{
    return switch(self){
      case TOf(head,rest)       : __.couple(head,rest);
    }
  }
}